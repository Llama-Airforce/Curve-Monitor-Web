import{k as ye,l as De,m as Re,n as Ve,o as ge,T as je,b as x,q as Oe,r as Ke,s as We,t as se,v as xe,w as we,I as Ye,x as Pe,y as Be,W as Je,e as Qe,j as Xe,h as O,i as Ze}from"./getAction-CU_Hxnbs.js";import{B as I,z as Ge,aH as et,s as ee,D as ae,p as tt,aI as W,aJ as S,x as V,aK as q,aL as N,aM as Ie,aN as K,aE as j,aO as nt,aP as J,aQ as ie,aR as st,aS as rt,aT as ot,aU as k,y as at,aV as it,aW as ct,aX as ce,aY as te,aZ as ut,a_ as ue,a$ as dt,b0 as ft,b1 as lt,b2 as ht,b3 as bt,b4 as pt,b5 as mt,b6 as yt}from"./index-BQLunFHs.js";class Fe extends I{constructor({docsPath:t}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:t,docsSlug:"account",name:"AccountNotFoundError"})}}class Q extends I{constructor({docsPath:t,metaMessages:n,type:s}){super(`Account type "${s}" is not supported.`,{docsPath:t,metaMessages:n,name:"AccountTypeNotSupportedError"})}}function gt(e){const t=Ge(`0x${e.substring(4)}`).substring(26);return et(`0x${t}`)}async function xt({hash:e,signature:t}){const n=ee(e)?e:ae(e),{secp256k1:s}=await tt(async()=>{const{secp256k1:a}=await import("./secp256k1-BrR9M5AQ.js");return{secp256k1:a}},[]);return`0x${(()=>{if(typeof t=="object"&&"r"in t&&"s"in t){const{r:u,s:l,v:c,yParity:f}=t,b=Number(f??c),h=de(b);return new s.Signature(W(u),W(l)).addRecoveryBit(h)}const a=ee(t)?t:ae(t),d=S(`0x${a.slice(130)}`),i=de(d);return s.Signature.fromCompact(a.substring(2,130)).addRecoveryBit(i)})().recoverPublicKey(n.substring(2)).toHex(!1)}`}function de(e){if(e===0||e===1)return e;if(e===27)return 0;if(e===28)return 1;throw new Error("Invalid yParityOrV value")}async function wt({hash:e,signature:t}){return gt(await xt({hash:e,signature:t}))}function Pt(e,t="hex"){const n=Te(e),s=ye(new Uint8Array(n.length));return n.encode(s),t==="hex"?V(s.bytes):s.bytes}function Te(e){return Array.isArray(e)?Bt(e.map(t=>Te(t))):Gt(e)}function Bt(e){const t=e.reduce((r,o)=>r+o.length,0),n=ke(t);return{length:t<=55?1+t:1+n+t,encode(r){t<=55?r.pushByte(192+t):(r.pushByte(247+n),n===1?r.pushUint8(t):n===2?r.pushUint16(t):n===3?r.pushUint24(t):r.pushUint32(t));for(const{encode:o}of e)o(r)}}}function Gt(e){const t=typeof e=="string"?q(e):e,n=ke(t.length);return{length:t.length===1&&t[0]<128?1:t.length<=55?1+t.length:1+n+t.length,encode(r){t.length===1&&t[0]<128?r.pushBytes(t):t.length<=55?(r.pushByte(128+t.length),r.pushBytes(t)):(r.pushByte(183+n),n===1?r.pushUint8(t.length):n===2?r.pushUint16(t.length):n===3?r.pushUint24(t.length):r.pushUint32(t.length),r.pushBytes(t))}}}function ke(e){if(e<2**8)return 1;if(e<2**16)return 2;if(e<2**24)return 3;if(e<2**32)return 4;throw new I("Length is too large.")}function It(e){const{chainId:t,nonce:n,to:s}=e,r=e.contractAddress??e.address,o=Ge(De(["0x05",Pt([t?N(t):"0x",r,n?N(n):"0x"])]));return s==="bytes"?q(o):o}async function Ne(e){const{authorization:t,signature:n}=e;return wt({hash:It(t),signature:n??t})}function Ft({chain:e,currentChainId:t}){if(!e)throw new Re;if(t!==e.id)throw new Ve({chain:e,currentChainId:t})}function Tt(e,{docsPath:t,...n}){const s=(()=>{const r=ge(e,n);return r instanceof Ie?e:r})();return new je(s,{docsPath:t,...n})}async function Ce(e){const t=await e.request({method:"eth_chainId"},{dedupe:!0});return S(t)}class kt extends I{constructor(){super("`baseFeeMultiplier` must be greater than 1.",{name:"BaseFeeScalarError"})}}class re extends I{constructor(){super("Chain does not support EIP-1559 fees.",{name:"Eip1559FeesNotSupportedError"})}}class Nt extends I{constructor({maxPriorityFeePerGas:t}){super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${K(t)} gwei).`,{name:"MaxFeePerGasTooLowError"})}}class ve extends I{constructor({blockHash:t,blockNumber:n}){let s="Block";t&&(s=`Block at hash "${t}"`),n&&(s=`Block at number "${n}"`),super(`${s} could not be found.`,{name:"BlockNotFoundError"})}}const Ee={"0x0":"legacy","0x1":"eip2930","0x2":"eip1559","0x3":"eip4844","0x4":"eip7702"};function _e(e){const t={...e,blockHash:e.blockHash?e.blockHash:null,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,chainId:e.chainId?S(e.chainId):void 0,gas:e.gas?BigInt(e.gas):void 0,gasPrice:e.gasPrice?BigInt(e.gasPrice):void 0,maxFeePerBlobGas:e.maxFeePerBlobGas?BigInt(e.maxFeePerBlobGas):void 0,maxFeePerGas:e.maxFeePerGas?BigInt(e.maxFeePerGas):void 0,maxPriorityFeePerGas:e.maxPriorityFeePerGas?BigInt(e.maxPriorityFeePerGas):void 0,nonce:e.nonce?S(e.nonce):void 0,to:e.to?e.to:null,transactionIndex:e.transactionIndex?Number(e.transactionIndex):null,type:e.type?Ee[e.type]:void 0,typeHex:e.type?e.type:void 0,value:e.value?BigInt(e.value):void 0,v:e.v?BigInt(e.v):void 0};return e.authorizationList&&(t.authorizationList=Ct(e.authorizationList)),t.yParity=(()=>{if(e.yParity)return Number(e.yParity);if(typeof t.v=="bigint"){if(t.v===0n||t.v===27n)return 0;if(t.v===1n||t.v===28n)return 1;if(t.v>=35n)return t.v%2n===0n?1:0}})(),t.type==="legacy"&&(delete t.accessList,delete t.maxFeePerBlobGas,delete t.maxFeePerGas,delete t.maxPriorityFeePerGas,delete t.yParity),t.type==="eip2930"&&(delete t.maxFeePerBlobGas,delete t.maxFeePerGas,delete t.maxPriorityFeePerGas),t.type==="eip1559"&&delete t.maxFeePerBlobGas,t}function Ct(e){return e.map(t=>({address:t.address,chainId:Number(t.chainId),nonce:Number(t.nonce),r:t.r,s:t.s,yParity:Number(t.yParity)}))}function vt(e){const t=(e.transactions??[]).map(n=>typeof n=="string"?n:_e(n));return{...e,baseFeePerGas:e.baseFeePerGas?BigInt(e.baseFeePerGas):null,blobGasUsed:e.blobGasUsed?BigInt(e.blobGasUsed):void 0,difficulty:e.difficulty?BigInt(e.difficulty):void 0,excessBlobGas:e.excessBlobGas?BigInt(e.excessBlobGas):void 0,gasLimit:e.gasLimit?BigInt(e.gasLimit):void 0,gasUsed:e.gasUsed?BigInt(e.gasUsed):void 0,hash:e.hash?e.hash:null,logsBloom:e.logsBloom?e.logsBloom:null,nonce:e.nonce?e.nonce:null,number:e.number?BigInt(e.number):null,size:e.size?BigInt(e.size):void 0,timestamp:e.timestamp?BigInt(e.timestamp):void 0,transactions:t,totalDifficulty:e.totalDifficulty?BigInt(e.totalDifficulty):null}}async function R(e,{blockHash:t,blockNumber:n,blockTag:s,includeTransactions:r}={}){var l,c,f;const o=s??"latest",a=r??!1,d=n!==void 0?N(n):void 0;let i=null;if(t?i=await e.request({method:"eth_getBlockByHash",params:[t,a]},{dedupe:!0}):i=await e.request({method:"eth_getBlockByNumber",params:[d||o,a]},{dedupe:!!d}),!i)throw new ve({blockHash:t,blockNumber:n});return(((f=(c=(l=e.chain)==null?void 0:l.formatters)==null?void 0:c.block)==null?void 0:f.format)||vt)(i)}async function Ae(e){const t=await e.request({method:"eth_gasPrice"});return BigInt(t)}async function Et(e,t){var o,a;const{block:n,chain:s=e.chain,request:r}=t||{};try{const d=((o=s==null?void 0:s.fees)==null?void 0:o.maxPriorityFeePerGas)??((a=s==null?void 0:s.fees)==null?void 0:a.defaultPriorityFee);if(typeof d=="function"){const u=n||await x(e,R,"getBlock")({}),l=await d({block:u,client:e,request:r});if(l===null)throw new Error;return l}if(typeof d<"u")return d;const i=await e.request({method:"eth_maxPriorityFeePerGas"});return W(i)}catch{const[d,i]=await Promise.all([n?Promise.resolve(n):x(e,R,"getBlock")({}),x(e,Ae,"getGasPrice")({})]);if(typeof d.baseFeePerGas!="bigint")throw new re;const u=i-d.baseFeePerGas;return u<0n?0n:u}}async function fe(e,t){var f,b;const{block:n,chain:s=e.chain,request:r,type:o="eip1559"}=t||{},a=await(async()=>{var h,m;return typeof((h=s==null?void 0:s.fees)==null?void 0:h.baseFeeMultiplier)=="function"?s.fees.baseFeeMultiplier({block:n,client:e,request:r}):((m=s==null?void 0:s.fees)==null?void 0:m.baseFeeMultiplier)??1.2})();if(a<1)throw new kt;const i=10**(((f=a.toString().split(".")[1])==null?void 0:f.length)??0),u=h=>h*BigInt(Math.ceil(a*i))/BigInt(i),l=n||await x(e,R,"getBlock")({});if(typeof((b=s==null?void 0:s.fees)==null?void 0:b.estimateFeesPerGas)=="function"){const h=await s.fees.estimateFeesPerGas({block:n,client:e,multiply:u,request:r,type:o});if(h!==null)return h}if(o==="eip1559"){if(typeof l.baseFeePerGas!="bigint")throw new re;const h=typeof(r==null?void 0:r.maxPriorityFeePerGas)=="bigint"?r.maxPriorityFeePerGas:await Et(e,{block:l,chain:s,request:r}),m=u(l.baseFeePerGas);return{maxFeePerGas:(r==null?void 0:r.maxFeePerGas)??m+h,maxPriorityFeePerGas:h}}return{gasPrice:(r==null?void 0:r.gasPrice)??u(await x(e,Ae,"getGasPrice")({}))}}class _t extends I{constructor(t,{account:n,docsPath:s,chain:r,data:o,gas:a,gasPrice:d,maxFeePerGas:i,maxPriorityFeePerGas:u,nonce:l,to:c,value:f}){var h;const b=Oe({from:n==null?void 0:n.address,to:c,value:typeof f<"u"&&`${Ke(f)} ${((h=r==null?void 0:r.nativeCurrency)==null?void 0:h.symbol)||"ETH"}`,data:o,gas:a,gasPrice:typeof d<"u"&&`${K(d)} gwei`,maxFeePerGas:typeof i<"u"&&`${K(i)} gwei`,maxPriorityFeePerGas:typeof u<"u"&&`${K(u)} gwei`,nonce:l});super(t.shortMessage,{cause:t,docsPath:s,metaMessages:[...t.metaMessages?[...t.metaMessages," "]:[],"Estimate Gas Arguments:",b].filter(Boolean),name:"EstimateGasExecutionError"}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cause=t}}function At(e,{docsPath:t,...n}){const s=(()=>{const r=ge(e,n);return r instanceof Ie?e:r})();return new _t(s,{docsPath:t,...n})}async function Ht(e,{address:t,blockNumber:n,blockTag:s="latest"}){const r=n?N(n):void 0,o=await e.request({method:"eth_getBalance",params:[t,r||s]});return BigInt(o)}async function Ut(e,t){var r,o,a;const{account:n=e.account}=t,s=n?j(n):void 0;try{let L=function(Y){const{block:D,request:H,rpcStateOverride:M}=Y;return e.request({method:"eth_estimateGas",params:M?[H,D??"latest",M]:D?[H,D]:[H]})};const{accessList:d,authorizationList:i,blobs:u,blobVersionedHashes:l,blockNumber:c,blockTag:f,data:b,gas:h,gasPrice:m,maxFeePerBlobGas:y,maxFeePerGas:g,maxPriorityFeePerGas:p,nonce:w,value:U,stateOverride:G,...P}=await Se(e,{...t,parameters:(s==null?void 0:s.type)==="local"?void 0:["blobVersionedHashes"]}),C=(c?N(c):void 0)||f,B=We(G),E=await(async()=>{if(P.to)return P.to;if(i&&i.length>0)return await Ne({authorization:i[0]}).catch(()=>{throw new I("`to` is required. Could not infer from `authorizationList`")})})();se(t);const T=(a=(o=(r=e.chain)==null?void 0:r.formatters)==null?void 0:o.transactionRequest)==null?void 0:a.format,v=(T||xe)({...we(P,{format:T}),from:s==null?void 0:s.address,accessList:d,authorizationList:i,blobs:u,blobVersionedHashes:l,data:b,gas:h,gasPrice:m,maxFeePerBlobGas:y,maxFeePerGas:g,maxPriorityFeePerGas:p,nonce:w,to:E,value:U});let z=BigInt(await L({block:C,request:v,rpcStateOverride:B}));if(i){const Y=await Ht(e,{address:v.from}),D=await Promise.all(i.map(async H=>{const{address:M}=H,$e=await L({block:C,request:{authorizationList:void 0,data:b,from:s==null?void 0:s.address,to:M,value:N(Y)},rpcStateOverride:B}).catch(()=>100000n);return 2n*BigInt($e)}));z+=D.reduce((H,M)=>H+M,0n)}return z}catch(d){throw At(d,{...t,account:s,chain:e.chain})}}async function Lt(e,{address:t,blockTag:n="latest",blockNumber:s}){const r=await e.request({method:"eth_getTransactionCount",params:[t,s?N(s):n]},{dedupe:!!s});return S(r)}function He(e){const{kzg:t}=e,n=e.to??(typeof e.blobs[0]=="string"?"hex":"bytes"),s=typeof e.blobs[0]=="string"?e.blobs.map(o=>q(o)):e.blobs,r=[];for(const o of s)r.push(Uint8Array.from(t.blobToKzgCommitment(o)));return n==="bytes"?r:r.map(o=>V(o))}function Ue(e){const{kzg:t}=e,n=e.to??(typeof e.blobs[0]=="string"?"hex":"bytes"),s=typeof e.blobs[0]=="string"?e.blobs.map(a=>q(a)):e.blobs,r=typeof e.commitments[0]=="string"?e.commitments.map(a=>q(a)):e.commitments,o=[];for(let a=0;a<s.length;a++){const d=s[a],i=r[a];o.push(Uint8Array.from(t.computeBlobKzgProof(d,i)))}return n==="bytes"?o:o.map(a=>V(a))}function zt(e,t,n,s){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,n,s);const r=BigInt(32),o=BigInt(4294967295),a=Number(n>>r&o),d=Number(n&o),i=s?4:0,u=s?0:4;e.setUint32(t+i,a,s),e.setUint32(t+u,d,s)}function Mt(e,t,n){return e&t^~e&n}function St(e,t,n){return e&t^e&n^t&n}class qt extends nt{constructor(t,n,s,r){super(),this.blockLen=t,this.outputLen=n,this.padOffset=s,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=J(this.buffer)}update(t){ie(this);const{view:n,buffer:s,blockLen:r}=this;t=st(t);const o=t.length;for(let a=0;a<o;){const d=Math.min(r-this.pos,o-a);if(d===r){const i=J(t);for(;r<=o-a;a+=r)this.process(i,a);continue}s.set(t.subarray(a,a+d),this.pos),this.pos+=d,a+=d,this.pos===r&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){ie(this),rt(t,this),this.finished=!0;const{buffer:n,view:s,blockLen:r,isLE:o}=this;let{pos:a}=this;n[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>r-a&&(this.process(s,0),a=0);for(let c=a;c<r;c++)n[c]=0;zt(s,r-8,BigInt(this.length*8),o),this.process(s,0);const d=J(t),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=i/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let c=0;c<u;c++)d.setUint32(4*c,l[c],o)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const s=t.slice(0,n);return this.destroy(),s}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:n,buffer:s,length:r,finished:o,destroyed:a,pos:d}=this;return t.length=r,t.pos=d,t.finished=o,t.destroyed=a,r%n&&t.buffer.set(s),t}}const $t=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),_=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),A=new Uint32Array(64);class Dt extends qt{constructor(){super(64,32,8,!1),this.A=_[0]|0,this.B=_[1]|0,this.C=_[2]|0,this.D=_[3]|0,this.E=_[4]|0,this.F=_[5]|0,this.G=_[6]|0,this.H=_[7]|0}get(){const{A:t,B:n,C:s,D:r,E:o,F:a,G:d,H:i}=this;return[t,n,s,r,o,a,d,i]}set(t,n,s,r,o,a,d,i){this.A=t|0,this.B=n|0,this.C=s|0,this.D=r|0,this.E=o|0,this.F=a|0,this.G=d|0,this.H=i|0}process(t,n){for(let c=0;c<16;c++,n+=4)A[c]=t.getUint32(n,!1);for(let c=16;c<64;c++){const f=A[c-15],b=A[c-2],h=k(f,7)^k(f,18)^f>>>3,m=k(b,17)^k(b,19)^b>>>10;A[c]=m+A[c-7]+h+A[c-16]|0}let{A:s,B:r,C:o,D:a,E:d,F:i,G:u,H:l}=this;for(let c=0;c<64;c++){const f=k(d,6)^k(d,11)^k(d,25),b=l+f+Mt(d,i,u)+$t[c]+A[c]|0,m=(k(s,2)^k(s,13)^k(s,22))+St(s,r,o)|0;l=u,u=i,i=d,d=a+b|0,a=o,o=r,r=s,s=b+m|0}s=s+this.A|0,r=r+this.B|0,o=o+this.C|0,a=a+this.D|0,d=d+this.E|0,i=i+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(s,r,o,a,d,i,u,l)}roundClean(){A.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Rt=ot(()=>new Dt);function Vt(e,t){return Rt(ee(e,{strict:!1})?at(e):e)}function jt(e){const{commitment:t,version:n=1}=e,s=e.to??(typeof t=="string"?"hex":"bytes"),r=Vt(t);return r.set([n],0),s==="bytes"?r:V(r)}function Ot(e){const{commitments:t,version:n}=e,s=e.to,r=[];for(const o of t)r.push(jt({commitment:o,to:s,version:n}));return r}const le=6,Le=32,oe=4096,ze=Le*oe,he=ze*le-1-1*oe*le;class Kt extends I{constructor({maxSize:t,size:n}){super("Blob size is too large.",{metaMessages:[`Max: ${t} bytes`,`Given: ${n} bytes`],name:"BlobSizeTooLargeError"})}}class Wt extends I{constructor(){super("Blob data must not be empty.",{name:"EmptyBlobError"})}}function Yt(e){const t=typeof e.data=="string"?q(e.data):e.data,n=it(t);if(!n)throw new Wt;if(n>he)throw new Kt({maxSize:he,size:n});const s=[];let r=!0,o=0;for(;r;){const a=ye(new Uint8Array(ze));let d=0;for(;d<oe;){const i=t.slice(o,o+(Le-1));if(a.pushByte(0),a.pushBytes(i),i.length<31){a.pushByte(128),r=!1;break}d++,o+=31}s.push(a)}return s.map(a=>V(a.bytes))}function Jt(e){const{data:t,kzg:n,to:s}=e,r=e.blobs??Yt({data:t}),o=e.commitments??He({blobs:r,kzg:n,to:s}),a=e.proofs??Ue({blobs:r,commitments:o,kzg:n,to:s}),d=[];for(let i=0;i<r.length;i++)d.push({blob:r[i],commitment:o[i],proof:a[i]});return d}function Qt(e){if(e.type)return e.type;if(typeof e.authorizationList<"u")return"eip7702";if(typeof e.blobs<"u"||typeof e.blobVersionedHashes<"u"||typeof e.maxFeePerBlobGas<"u"||typeof e.sidecars<"u")return"eip4844";if(typeof e.maxFeePerGas<"u"||typeof e.maxPriorityFeePerGas<"u")return"eip1559";if(typeof e.gasPrice<"u")return typeof e.accessList<"u"?"eip2930":"legacy";throw new Ye({transaction:e})}const Me=["blobVersionedHashes","chainId","fees","gas","nonce","type"],be=new Map;async function Se(e,t){const{account:n=e.account,blobs:s,chain:r,gas:o,kzg:a,nonce:d,nonceManager:i,parameters:u=Me,type:l}=t,c=n&&j(n),f={...t,...c?{from:c==null?void 0:c.address}:{}};let b;async function h(){return b||(b=await x(e,R,"getBlock")({blockTag:"latest"}),b)}let m;async function y(){return m||(r?r.id:typeof t.chainId<"u"?t.chainId:(m=await x(e,Ce,"getChainId")({}),m))}if(u.includes("nonce")&&typeof d>"u"&&c)if(i){const g=await y();f.nonce=await i.consume({address:c.address,chainId:g,client:e})}else f.nonce=await x(e,Lt,"getTransactionCount")({address:c.address,blockTag:"pending"});if((u.includes("blobVersionedHashes")||u.includes("sidecars"))&&s&&a){const g=He({blobs:s,kzg:a});if(u.includes("blobVersionedHashes")){const p=Ot({commitments:g,to:"hex"});f.blobVersionedHashes=p}if(u.includes("sidecars")){const p=Ue({blobs:s,commitments:g,kzg:a}),w=Jt({blobs:s,commitments:g,proofs:p,to:"hex"});f.sidecars=w}}if(u.includes("chainId")&&(f.chainId=await y()),(u.includes("fees")||u.includes("type"))&&typeof l>"u")try{f.type=Qt(f)}catch{let g=be.get(e.uid);if(typeof g>"u"){const p=await h();g=typeof(p==null?void 0:p.baseFeePerGas)=="bigint",be.set(e.uid,g)}f.type=g?"eip1559":"legacy"}if(u.includes("fees"))if(f.type!=="legacy"&&f.type!=="eip2930"){if(typeof f.maxFeePerGas>"u"||typeof f.maxPriorityFeePerGas>"u"){const g=await h(),{maxFeePerGas:p,maxPriorityFeePerGas:w}=await fe(e,{block:g,chain:r,request:f});if(typeof t.maxPriorityFeePerGas>"u"&&t.maxFeePerGas&&t.maxFeePerGas<w)throw new Nt({maxPriorityFeePerGas:w});f.maxPriorityFeePerGas=w,f.maxFeePerGas=p}}else{if(typeof t.maxFeePerGas<"u"||typeof t.maxPriorityFeePerGas<"u")throw new re;if(typeof t.gasPrice>"u"){const g=await h(),{gasPrice:p}=await fe(e,{block:g,chain:r,request:f,type:"legacy"});f.gasPrice=p}}return u.includes("gas")&&typeof o>"u"&&(f.gas=await x(e,Ut,"estimateGas")({...f,account:c&&{address:c.address,type:"json-rpc"}})),se(f),delete f.parameters,f}async function Xt(e,{serializedTransaction:t}){return e.request({method:"eth_sendRawTransaction",params:[t]},{retryCount:0})}const X=new ct(128);async function Zt(e,t){var g,p,w,U;const{account:n=e.account,chain:s=e.chain,accessList:r,authorizationList:o,blobs:a,data:d,gas:i,gasPrice:u,maxFeePerBlobGas:l,maxFeePerGas:c,maxPriorityFeePerGas:f,nonce:b,value:h,...m}=t;if(typeof n>"u")throw new Fe({docsPath:"/docs/actions/wallet/sendTransaction"});const y=n?j(n):null;try{se(t);const G=await(async()=>{if(t.to)return t.to;if(t.to!==null&&o&&o.length>0)return await Ne({authorization:o[0]}).catch(()=>{throw new I("`to` is required. Could not infer from `authorizationList`.")})})();if((y==null?void 0:y.type)==="json-rpc"||y===null){let P;s!==null&&(P=await x(e,Ce,"getChainId")({}),Ft({currentChainId:P,chain:s}));const F=(w=(p=(g=e.chain)==null?void 0:g.formatters)==null?void 0:p.transactionRequest)==null?void 0:w.format,B=(F||xe)({...we(m,{format:F}),accessList:r,authorizationList:o,blobs:a,chainId:P,data:d,from:y==null?void 0:y.address,gas:i,gasPrice:u,maxFeePerBlobGas:l,maxFeePerGas:c,maxPriorityFeePerGas:f,nonce:b,to:G,value:h}),E=X.get(e.uid),T=E?"wallet_sendTransaction":"eth_sendTransaction";try{return await e.request({method:T,params:[B]},{retryCount:0})}catch($){if(E===!1)throw $;const v=$;if(v.name==="InvalidInputRpcError"||v.name==="InvalidParamsRpcError"||v.name==="MethodNotFoundRpcError"||v.name==="MethodNotSupportedRpcError")return await e.request({method:"wallet_sendTransaction",params:[B]},{retryCount:0}).then(L=>(X.set(e.uid,!0),L)).catch(L=>{const z=L;throw z.name==="MethodNotFoundRpcError"||z.name==="MethodNotSupportedRpcError"?(X.set(e.uid,!1),v):z});throw v}}if((y==null?void 0:y.type)==="local"){const P=await x(e,Se,"prepareTransactionRequest")({account:y,accessList:r,authorizationList:o,blobs:a,chain:s,data:d,gas:i,gasPrice:u,maxFeePerBlobGas:l,maxFeePerGas:c,maxPriorityFeePerGas:f,nonce:b,nonceManager:y.nonceManager,parameters:[...Me,"sidecars"],value:h,...m,to:G}),F=(U=s==null?void 0:s.serializers)==null?void 0:U.transaction,C=await y.signTransaction(P,{serializer:F});return await x(e,Xt,"sendRawTransaction")({serializedTransaction:C})}throw(y==null?void 0:y.type)==="smart"?new Q({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new Q({docsPath:"/docs/actions/wallet/sendTransaction",type:y==null?void 0:y.type})}catch(G){throw G instanceof Q?G:Tt(G,{...t,account:y,chain:t.chain||void 0})}}const en=new Map,tn=new Map;function nn(e){const t=(r,o)=>({clear:()=>o.delete(r),get:()=>o.get(r),set:a=>o.set(r,a)}),n=t(e,en),s=t(e,tn);return{clear:()=>{n.clear(),s.clear()},promise:n,response:s}}async function sn(e,{cacheKey:t,cacheTime:n=Number.POSITIVE_INFINITY}){const s=nn(t),r=s.response.get();if(r&&n>0&&new Date().getTime()-r.created.getTime()<n)return r.data;let o=s.promise.get();o||(o=e(),s.promise.set(o));try{const a=await o;return s.response.set({created:new Date,data:a}),a}finally{s.promise.clear()}}const rn=e=>`blockNumber.${e}`;async function on(e,{cacheTime:t=e.cacheTime}={}){const n=await sn(()=>e.request({method:"eth_blockNumber"}),{cacheKey:rn(e.uid),cacheTime:t});return BigInt(n)}function an(e,{args:t,eventName:n}={}){return{...e,blockHash:e.blockHash?e.blockHash:null,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,logIndex:e.logIndex?Number(e.logIndex):null,transactionHash:e.transactionHash?e.transactionHash:null,transactionIndex:e.transactionIndex?Number(e.transactionIndex):null,...n?{args:t,eventName:n}:{}}}async function qe(e,{blockHash:t,blockNumber:n,blockTag:s,hash:r,index:o}){var l,c,f;const a=s||"latest",d=n!==void 0?N(n):void 0;let i=null;if(r?i=await e.request({method:"eth_getTransactionByHash",params:[r]},{dedupe:!0}):t?i=await e.request({method:"eth_getTransactionByBlockHashAndIndex",params:[t,N(o)]},{dedupe:!0}):i=await e.request({method:"eth_getTransactionByBlockNumberAndIndex",params:[d||a,N(o)]},{dedupe:!!d}),!i)throw new Pe({blockHash:t,blockNumber:n,blockTag:a,hash:r,index:o});return(((f=(c=(l=e.chain)==null?void 0:l.formatters)==null?void 0:c.transaction)==null?void 0:f.format)||_e)(i)}const cn={"0x0":"reverted","0x1":"success"};function un(e){const t={...e,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,contractAddress:e.contractAddress?e.contractAddress:null,cumulativeGasUsed:e.cumulativeGasUsed?BigInt(e.cumulativeGasUsed):null,effectiveGasPrice:e.effectiveGasPrice?BigInt(e.effectiveGasPrice):null,gasUsed:e.gasUsed?BigInt(e.gasUsed):null,logs:e.logs?e.logs.map(n=>an(n)):null,to:e.to?e.to:null,transactionIndex:e.transactionIndex?S(e.transactionIndex):null,status:e.status?cn[e.status]:null,type:e.type?Ee[e.type]||e.type:null};return e.blobGasPrice&&(t.blobGasPrice=BigInt(e.blobGasPrice)),e.blobGasUsed&&(t.blobGasUsed=BigInt(e.blobGasUsed)),t}async function pe(e,{hash:t}){var r,o,a;const n=await e.request({method:"eth_getTransactionReceipt",params:[t]},{dedupe:!0});if(!n)throw new Be({hash:t});return(((a=(o=(r=e.chain)==null?void 0:r.formatters)==null?void 0:o.transactionReceipt)==null?void 0:a.format)||un)(n)}const Z=new Map,me=new Map;let dn=0;function ne(e,t,n){const s=++dn,r=()=>Z.get(e)||[],o=()=>{const l=r();Z.set(e,l.filter(c=>c.id!==s))},a=()=>{const l=r();if(!l.some(f=>f.id===s))return;const c=me.get(e);l.length===1&&c&&c(),o()},d=r();if(Z.set(e,[...d,{id:s,fns:t}]),d&&d.length>0)return a;const i={};for(const l in t)i[l]=(...c)=>{var b,h;const f=r();if(f.length!==0)for(const m of f)(h=(b=m.fns)[l])==null||h.call(b,...c)};const u=n(i);return typeof u=="function"&&me.set(e,u),a}function fn(e,{emitOnBegin:t,initialWaitTime:n,interval:s}){let r=!0;const o=()=>r=!1;return(async()=>{let d;t&&(d=await e({unpoll:o}));const i=await(n==null?void 0:n(d))??s;await ce(i);const u=async()=>{r&&(await e({unpoll:o}),await ce(s),u())};u()})(),o}function ln(e,{emitOnBegin:t=!1,emitMissed:n=!1,onBlockNumber:s,onError:r,poll:o,pollingInterval:a=e.pollingInterval}){const d=typeof o<"u"?o:!(e.transport.type==="webSocket"||e.transport.type==="fallback"&&e.transport.transports[0].config.type==="webSocket");let i;return d?(()=>{const c=te(["watchBlockNumber",e.uid,t,n,a]);return ne(c,{onBlockNumber:s,onError:r},f=>fn(async()=>{var b;try{const h=await x(e,on,"getBlockNumber")({cacheTime:0});if(i){if(h===i)return;if(h-i>1&&n)for(let m=i+1n;m<h;m++)f.onBlockNumber(m,i),i=m}(!i||h>i)&&(f.onBlockNumber(h,i),i=h)}catch(h){(b=f.onError)==null||b.call(f,h)}},{emitOnBegin:t,interval:a}))})():(()=>{const c=te(["watchBlockNumber",e.uid,t,n]);return ne(c,{onBlockNumber:s,onError:r},f=>{let b=!0,h=()=>b=!1;return(async()=>{try{const m=(()=>{if(e.transport.type==="fallback"){const g=e.transport.transports.find(p=>p.config.type==="webSocket");return g?g.value:e.transport}return e.transport})(),{unsubscribe:y}=await m.subscribe({params:["newHeads"],onData(g){var w;if(!b)return;const p=W((w=g.result)==null?void 0:w.number);f.onBlockNumber(p,i),i=p},onError(g){var p;(p=f.onError)==null||p.call(f,g)}});h=y,b||h()}catch(m){r==null||r(m)}})(),()=>h()})})()}async function hn(e,{confirmations:t=1,hash:n,onReplaced:s,pollingInterval:r=e.pollingInterval,retryCount:o=6,retryDelay:a=({count:i})=>~~(1<<i)*200,timeout:d=18e4}){const i=te(["waitForTransactionReceipt",e.uid,n]);let u,l,c,f=!1;const{promise:b,resolve:h,reject:m}=ut(),y=d?setTimeout(()=>m(new Je({hash:n})),d):void 0,g=ne(i,{onReplaced:s,resolve:h,reject:m},p=>{const w=x(e,ln,"watchBlockNumber")({emitMissed:!0,emitOnBegin:!0,poll:!0,pollingInterval:r,async onBlockNumber(U){const G=F=>{clearTimeout(y),w(),F(),g()};let P=U;if(!f)try{if(c){if(t>1&&(!c.blockNumber||P-c.blockNumber+1n<t))return;G(()=>p.resolve(c));return}if(u||(f=!0,await ue(async()=>{u=await x(e,qe,"getTransaction")({hash:n}),u.blockNumber&&(P=u.blockNumber)},{delay:a,retryCount:o}),f=!1),c=await x(e,pe,"getTransactionReceipt")({hash:n}),t>1&&(!c.blockNumber||P-c.blockNumber+1n<t))return;G(()=>p.resolve(c))}catch(F){if(F instanceof Pe||F instanceof Be){if(!u){f=!1;return}try{l=u,f=!0;const C=await ue(()=>x(e,R,"getBlock")({blockNumber:P,includeTransactions:!0}),{delay:a,retryCount:o,shouldRetry:({error:T})=>T instanceof ve});f=!1;const B=C.transactions.find(({from:T,nonce:$})=>T===l.from&&$===l.nonce);if(!B||(c=await x(e,pe,"getTransactionReceipt")({hash:B.hash}),t>1&&(!c.blockNumber||P-c.blockNumber+1n<t)))return;let E="replaced";B.to===l.to&&B.value===l.value&&B.input===l.input?E="repriced":B.from===B.to&&B.value===0n&&(E="cancelled"),G(()=>{var T;(T=p.onReplaced)==null||T.call(p,{reason:E,replacedTransaction:l,transaction:B,transactionReceipt:c}),p.resolve(c)})}catch(C){G(()=>p.reject(C))}}else G(()=>p.reject(F))}}})});return b}async function bn(e,t){const{abi:n,account:s=e.account,address:r,args:o,dataSuffix:a,functionName:d,...i}=t;if(typeof s>"u")throw new Fe({docsPath:"/docs/contract/writeContract"});const u=s?j(s):null,l=Qe({abi:n,args:o,functionName:d});try{return await x(e,Zt,"sendTransaction")({data:`${l}${a?a.replace("0x",""):""}`,to:r,account:u,...i})}catch(c){throw Xe(c,{abi:n,address:r,args:o,docsPath:"/docs/contract/writeContract",functionName:d,sender:u==null?void 0:u.address})}}function pn(e,t={}){const{key:n="custom",methods:s,name:r="Custom Provider",retryDelay:o}=t;return({retryCount:a})=>dt({key:n,methods:s,name:r,request:e.request.bind(e),retryCount:t.retryCount??a,retryDelay:o,type:"custom"})}async function mn(e,t={}){let n;if(t.connector){const{connector:u}=t;if(e.state.status==="reconnecting"&&!u.getAccounts&&!u.getChainId)throw new ft({connector:u});const[l,c]=await Promise.all([u.getAccounts().catch(f=>{if(t.account===null)return[];throw f}),u.getChainId()]);n={accounts:l,chainId:c,connector:u}}else n=e.state.connections.get(e.state.current);if(!n)throw new lt;const s=t.chainId??n.chainId,r=await n.connector.getChainId();if(r!==n.chainId)throw new ht({connectionChainId:n.chainId,connectorChainId:r});const o=n.connector;if(o.getClient)return o.getClient({chainId:s});const a=j(t.account??n.accounts[0]);if(a&&(a.address=bt(a.address)),t.account&&!n.accounts.some(u=>u.toLowerCase()===a.address.toLowerCase()))throw new pt({address:a.address,connector:o});const d=e.chains.find(u=>u.id===s),i=await n.connector.getProvider({chainId:s});return mt({account:a,chain:d,name:"Connector Client",transport:u=>pn(i)({...u,retryCount:0})})}async function xn(e,t){const{chainId:n,timeout:s=0,...r}=t,o=e.getClient({chainId:n}),d=await O(o,hn,"waitForTransactionReceipt")({...r,timeout:s});if(d.status==="reverted"){const u=await O(o,qe,"getTransaction")({hash:d.transactionHash}),c=await O(o,Ze,"call")({...u,data:u.input,gasPrice:u.type!=="eip1559"?u.gasPrice:void 0,maxFeePerGas:u.type==="eip1559"?u.maxFeePerGas:void 0,maxPriorityFeePerGas:u.type==="eip1559"?u.maxPriorityFeePerGas:void 0}),f=c!=null&&c.data?yt(`0x${c.data.substring(138)}`):"unknown reason";throw new Error(f)}return{...d,chainId:o.chain.id}}async function wn(e,t){const{account:n,chainId:s,connector:r,...o}=t;let a;return typeof n=="object"&&(n==null?void 0:n.type)==="local"?a=e.getClient({chainId:s}):a=await mn(e,{account:n??void 0,chainId:s,connector:r}),await O(a,bn,"writeContract")({...o,...n?{account:n}:{},chain:s?{id:s}:null})}export{wn as a,mn as g,xn as w};
